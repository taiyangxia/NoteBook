公司计划面试 2n 人。给你一个数组 costs ，其中 costs[i] = [aCosti, bCosti] 。第 i 人飞往 a 市的费用为 aCosti ，飞往 b 市的费用为 bCosti 。

返回将每个人都飞到 a 、b 中某座城市的最低费用，要求每个城市都有 n 人抵达。


示例 1：

输入：costs = [[10,20],[30,200],[400,50],[30,20]]
输出：110
解释：
第一个人去 a 市，费用为 10。
第二个人去 a 市，费用为 30。
第三个人去 b 市，费用为 50。
第四个人去 b 市，费用为 20。

最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。

思路：可以是暴力回溯 
但是对于此问题，有一个 比较巧妙的方法：

## 先让 所有人去往 A；然后计算出 每个人 往 A B调度时的费用的差值，计算结束后，按差值最大的优先，选出 一半人 去B即可 

```
class Solution {
public:
    int twoCitySchedCost(vector<vector<int>>& costs) {
        vector<int>Gap(costs.size());
        int res=0;
        for(int i=0;i<costs.size();i++){
            res+=costs[i][0];
            Gap[i]=(costs[i][0]-costs[i][1]);        // 去 A 比 去 B 多消耗多少
        }
        
        int count=costs.size()/2;
        
        sort(Gap.begin(),Gap.end(),[](int & a,int& b){
            return a>b;
        });
        
        int index=0;
        // 这里是选出 一半去A比去B差值最高的的人，让他们去B  计算公式：首先 cost[B]=cost[A]-Gap[i]; 所以 对于 res而言，先减去A的消费，再加上B的消费记为 此时总消费： res - cost[A]+cost[B]=res - cost[A] + cost[A] -Gap[i] = res -Gap[i]
        while(count--){
            res-=Gap[index++];
        }

        return res;
    }
};
```

核心思路：先全去一方，然后 对每个人的调度进行差值比较；从上到下再去选：本应去对面的人！！