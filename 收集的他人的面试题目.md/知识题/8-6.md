# 怎么强制不让结构体对齐

结构体对齐：方便CPU查找；因为 cpu的查找，为了提高效率，不是一个一个字节来的

# 模板T 可以有 默认类型  
\<template T=char\>     然后,当在函数中 无法自动推导出函数类型时，会使用此默认类型！ 但是  函数传的参数的默认初始值，不会作为模板参数推导依据    

```
<template T,template U=char> 
void fun(T=100,U=100){
    cout<<U<<endl;
    cout<<T<<endl;                // 报错 因为T无法自动推导出来类型，且没给出 默认参数 （形参 100不能作为推导依据（100可以是 int 也可以是 'd'）  归根到底：自动推导时，不能有歧义）
}

```

# assert 断言  （相当于强制判断语句，若此处断言结果为假，则程序退出）

如： assert(size>0);         (程序运行到此处时，size若《0，则退出)

静态断言：不同环境下断言结果不同，需要等程序跑在一个确定的环境/平台下，才可确定：

assert(sizeof(long long)==8);   $\color{green}{用来判断程序是否在64位环境下运行，若不是则退出程序}$

# throw 抛出异常   noexcept 在函数后面修饰，表明此函数不会出错，若出错，则终止程序运行
***   throw ***; 抛出异常  try {执行逻辑}  catch (抓住异常信息) {执行逻辑}  catch(抓住抛出的异常变量){执行逻辑}

noexcept 后可跟参数
noexcept(true)     表明函数不会异常
noexcept(false)    表明函数可能异常

```
struct MyException
{
    MyException(string s) :msg(s) {}
    string msg;
};

double divisionMethod(int a, int b) throw(MyException, int)
{
    if (b == 0)
    {
        throw MyException("division by zero!!!");
        // throw 100;
    }
    return a / b;
}

int main()
{
    try
    {	
        double v = divisionMethod(100, 0);
        cout << "value: " << v << endl;
    }
    catch (int e)
    {
        cout << "catch except: "  << e << endl;
    }
    catch (MyException e)
    {
        cout << "catch except: " << e.msg << endl;
    }
    return 0;
}
```


# auto
有时候很像自动“补全”

int temp=250;

auto p=temp;        // auto = int  (因为p的类型是int)

auto *p=&temp;     // auto =int （因为p的类型是int\*）

auto p=&temp;      // auto =int*（因为p的类型是int\*）

# new
我们学完内存管理后，再回头看 new： 再堆上new出一个对象，new出什么样的对象，是看 new后跟着的是什么：
1. new int[10]  new出一个整型数组   $\color{green}{注意：new后跟着的都是 定义过的变量，直接匿名，不用 你再加什么变量名了，new int arr[10]}$
2. new Person();       $\color{green}{创建一个Person对象}$
     **那其实这里 只要是Person可以用的构造方式，这里new后就可以跟着，并new出一个对象。（也就是说 你正常怎么创建一个 Person类对象，这里new后面就怎么写（因为 new就是再调用构造函数））**

    $\color{blue}{1.动态数组实现:}$
    int* arr= new int[length];         // new的返回值是int*  所以 arr 是 int*
    $\color{blue}{2.正常int对象:}$
    int* arr = new int;


    # 数组定义时的“length”
    首先明白 int arr [num];在表明arr的长度时，该num需要是一个 常量！！！
        1、num = 123;    // 立即数直接赋值，则num是一个常量
        2、const int a = 123;  const int b = a;  (b为常量 a为常量 将a赋值给b)
        
        注意 int a=10; const int b=a;   
        int arr[b]={1,2,3...};   // 报错 b no常量
    $\color{blue}{a是变量，而const 修饰b这里只是说，b是一个只读的变量！所以声明数组arr时报错}$
       
    $\color{red}{Note:关于 const还要说：}$
    通过上面的例子也能知道，const 并不是代表数据是常量，只能代表数据可读！！！
        int a=10;
        const int& b=a;   // b是一个可读数据，且是a变量的引用;这里const只是限制：不能通过b去更改a的值;但是a的值改变了，会反应在 b上！！
        cout<<b<<endl;    // 10
        a=20;
        cout<<b<<endl;    // 20
    其实看之前编码时，我们常用 const char* path;形参，但是这只是说，不能通过path去更改内存里的内容，但是每次传进来的path是可以不同的，（$\color{red}{path是一个变量！只不过该变量只读}$） 
    
    C++11 中 新增关键字  constexpr 这个是真正可以修饰常量表达式的
    (常量表达时，只在编译时处理一次，而不是在每一次程序运行时，都做一次处理！)
    [https://subingwen.cn/cpp/constexpr/#1-1-const]
        1. constexpr 修饰自定义数据时，对 struct 和 class 的声明和定义处是无效的 
            constexpr struct Person{ int id; int name;};       // 无效
            只能对 struct或class 的对象，进行constexpr修饰，constexpr Person p1{1,2};  // 且修饰后，p1整体都是一个常量，里面的id和name均不可修改
        2. C++11，constexpr可以修饰函数；但是函数必须有返回值且返回值是常量；但是 C++17放宽这一要求
        3. 整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return语句除外）。

# 指针：可以指向堆，可以指向栈，可以指向全局变量；指针本身确实是栈上数据，对应函数调用结束，则指针本身被消耗；但是，其指向的数据是否还能再访问，要看数据本身在哪个区

```
char * Func(){
    char* str="hello world";
    char arr[]="hello world";

    return str;
    // return arr;
}

int main(){
    char* p;
    p=Func();

    printf("%s\n",p);
}
```

对于上面的代码而言：如果 Func函数返回的是，str，那么main函数运行正确；因为$\color{red}{函数的返回值是按照拷贝赋值进行返回的，这里相当于返回一个str的64位指针数据的拷贝给p}$，然后又因为str指向的是全局区的常量，所以Func函数结束后，该常量还在，str指针虽然销毁了，但是 该指针指向的内容任然有效！！！所以 main函数对p指针进行解引用，运行正确；

但是，如果返回的是 arr：
首先看 char arr="hello world"; 这句话的意思是：在栈上，创建一个数组，然后用 hello world字符串填充，arr指向的是该栈上数组的位置;$\color{red}{所以,这里，char* 和 char[] 看似一样，实则差很多,char* 指向全局区}$
int a=10;   a也是常量赋值，但是a是栈上数据；且 int*p=&a;也是指向一个栈上数据    
所以,上面的 main函数,p接收Func返回的arr后，是报错的！！！！（尽管，有些编译器吗，这样返回可运行，但是，这的的确确是一个非常危险的操作！！）
